import flask
from flask import request
from flask_cors import cross_origin
import json

from feeds.activity.notification import Notification
from feeds.managers.notification_manager import NotificationManager
from feeds.feeds.notification.notification_feed import NotificationFeed
from feeds.external_api.auth import (
    validate_user_token,
    validate_service_token,
    get_auth_token,
    is_feeds_admin
)
from feeds.external_api.groups import (
    get_user_groups
)
from feeds.exceptions import (
    InvalidTokenError,
    IllegalParameterError,
    MissingParameterError,
    NotificationNotFoundError
)
from feeds.config import get_config
from feeds.logger import log
from feeds.notification_level import translate_level
from feeds.verbs import translate_verb
from .util import (
    parse_notification_params,
    parse_expire_notifications_params,
    fetch_global_notifications,
    get_global_feed
)

cfg = get_config()
api_v1 = flask.Blueprint('api_v1', __name__)


@api_v1.route('/', methods=['GET'])
def root():
    resp = {
        'routes': {
            'root': 'GET /',
            'add_notification': 'POST /notification',
            'get_notifications': 'GET /notifications',
            'get_global_notifications': 'GET /notifications/global',
            'get_specific_notification': 'GET /notification/<note_id>',
            'mark_notifications_seen': 'POST /notifications/see',
            'mark_notifications_unseen': 'POST /notifications/unsee'
        }
    }
    return flask.jsonify(resp)


@api_v1.route('/notifications', methods=['GET'])
@cross_origin()
def get_notifications():
    """
    General flow should be:
    1. validate/authenticate user
    2. make user feed object
    3. query user feed for most recent, based on params
    """
    max_notes = request.args.get('n', default=cfg.default_max_notes, type=int)

    rev_sort = request.args.get('rev', default=0, type=int)
    rev_sort = False if rev_sort == 0 else True

    level_filter_input = request.args.get('l', default=None, type=str)
    level_filter = None
    if level_filter_input is not None:
        level_filter = translate_level(level_filter_input)

    verb_filter_input = request.args.get('v', default=None, type=str)
    verb_filter = None
    if verb_filter_input is not None:
        verb_filter = translate_verb(verb_filter_input)

    include_seen = request.args.get('seen', default=0, type=int)
    include_seen = False if include_seen == 0 else True
    user_token = get_auth_token(request)
    user_id = validate_user_token(user_token)
    log(__name__, 'Getting feed for {}'.format(user_id))

    feed = NotificationFeed(user_id, "user", token=user_token)
    user_notes = feed.get_notifications(
        count=max_notes, include_seen=include_seen, level=level_filter,
        verb=verb_filter, reverse=rev_sort, user_view=True
    )

    return_vals = {
        "user": user_notes,
        "global": fetch_global_notifications(count=max_notes)
    }

    user_groups = get_user_groups(user_token)
    for g in user_groups:
        # temporary until sometime after the GSP meeting when we work out
        # how to properly support following various channels and posting to
        # them and such.
        return_vals[g["id"]] = feed.get_group_notifications(
            g, count=max_notes, include_seen=include_seen, level=level_filter,
            verb=verb_filter, reverse=rev_sort
        )
        # feed = NotificationFeed(g["id"], "group")
        # return_vals[g["id"]] = feed.get_notifications(
        #     count=max_notes, include_seen=include_seen, level=level_filter,
        #     verb=verb_filter, reverse=rev_sort, user_view=True
        # )

    return (flask.jsonify(return_vals), 200)


@api_v1.route('/notification', methods=['POST'])
@cross_origin()
def add_notification():
    """
    Adds a new notification for other users to see.
    Form data requires the following:
    * `actor` - a user or org id.
    * `actor_type` - either 'user' or 'group'
    * `type` - one of the type keywords (see below, TBD (as of 10/8))
    * `target` - optional, a user or org id. - always receives this notification
    * `object` - object of the notice. For invitations, the group to be invited to.
        For narratives, the narrative UPA.
    * `level` - alert, error, warning, or request.
    * `content` - optional, content of the notification, otherwise it'll be
        autogenerated from the info above.
    * `global` - true or false. If true, gets added to the global notification
        feed and everyone gets a copy.
    * `expires` - int, optional time to expire a notifications.
    * `source` - string, the source service behind the notification. Used in some logic
        to determine which feeds receive the notification

    This also requires a service token as an Authorization header.
    """
    token = get_auth_token(request)
    try:
        validate_service_token(token)
    except InvalidTokenError:
        if cfg.debug:
            if not is_feeds_admin(token):
                raise InvalidTokenError('Auth token must be either a Service token '
                                        'or from a user with the FEEDS_ADMIN role!')
        else:
            raise
    log(__name__, request.get_data())
    params = parse_notification_params(json.loads(request.get_data()))
    # create a Notification from params.
    new_note = Notification(
        params.get('actor'),
        params.get('verb'),
        params.get('object'),
        params.get('source'),
        level=params.get('level'),
        target=params.get('target', []),
        context=params.get('context'),
        expires=params.get('expires'),
        external_key=params.get('external_key'),
        users=params.get('users', [])
    )
    # pass it to the NotificationManager to dole out to its audience feeds.
    manager = NotificationManager()
    manager.add_notification(new_note)
    # on success, return the notification id and info.
    return (flask.jsonify({'id': new_note.id}), 200)


@api_v1.route('/notifications/global', methods=['GET'])
@cross_origin()
def get_global_notifications():
    return (flask.jsonify(fetch_global_notifications()), 200)


@api_v1.route('/notifications/unseen_count', methods=['GET'])
@cross_origin()
def get_unseen_notification_count():
    user_token = get_auth_token(request)
    user_id = validate_user_token(user_token)
    feed = NotificationFeed(user_id, "user", token=user_token)
    user_count = feed.get_unseen_count()
    global_feed = get_global_feed()
    global_count = global_feed.get_unseen_count()
    ret_value = {
        "unseen": {
            "user": user_count,
            "global": global_count
        }
    }
    return (flask.jsonify(ret_value), 200)


@api_v1.route('/notification/external_key/<ext_key>/source/<source>', methods=['GET'])
@cross_origin()
def get_notification_by_ext_key(ext_key, source):
    """
    Intended for debugging, this returns the notification by
    external key for a service token. The service must match the
    source of the notification.
    """
    token = get_auth_token(request)
    try:
        validate_service_token(token)
    except InvalidTokenError:
        if not is_feeds_admin(token):
            raise InvalidTokenError('Auth token must be either a Service token '
                                    'or from a user with the FEEDS_ADMIN role!')
    manager = NotificationManager()
    notes = manager.get_notifications_by_ext_keys([ext_key], source)
    note = notes.get(ext_key)
    if note is None:
        raise NotificationNotFoundError(
            "Cannot find notification with external_key {} and "
            "source {}.".format(ext_key, source)
        )
    if "_id" in note:    # Don't need the internal Mongo record id here.
        del note["_id"]
    return (flask.jsonify({'notification': notes[ext_key]}), 200)


@api_v1.route('/notification/<note_id>', methods=['GET'])
@cross_origin()
def get_single_notification(note_id):
    """
    Should only return the note with that id if it's in the user's feed.
    """
    user_id = validate_user_token(get_auth_token(request))
    feed = NotificationFeed(user_id, "user")
    try:
        note = feed.get_notification(note_id)
    except NotificationNotFoundError:
        note = NotificationFeed(cfg.global_feed, cfg.global_feed_type).get_notification(note_id)
    return (flask.jsonify({'notification': note.user_view()}), 200)


@api_v1.route('/notifications/unsee', methods=['POST'])
@cross_origin()
def mark_notifications_unseen():
    """
    Form data should have a list of notification ids to mark as unseen.
    If any of these do not have the user's id (from the token) on the list,
    raise an error.
    Any of these ids that are global, do nothing... for now.
    """
    user_id = validate_user_token(get_auth_token(request))

    params = _get_mark_notification_params(json.loads(request.get_data()))
    note_ids = params.get('note_ids')

    feed = NotificationFeed(user_id, "user")
    unauthorized_notes = list()
    for note_id in note_ids:
        try:
            feed.get_notification(note_id)
        except NotificationNotFoundError:
            unauthorized_notes.append(note_id)

    unseen_notes = list(set(note_ids) - set(unauthorized_notes))
    feed.mark_activities(unseen_notes, seen=False)

    return (flask.jsonify({'unseen_notes': unseen_notes,
                           'unauthorized_notes': unauthorized_notes}), 200)


@api_v1.route('/notifications/see', methods=['POST'])
@cross_origin()
def mark_notifications_seen():
    """
    Form data should have a list of notification ids to mark as seen.
    If any of these do not have the user's id (from the token) on the list,
    raise an error.
    Any of these ids that are global, do nothing... for now.
    """
    user_id = validate_user_token(get_auth_token(request))

    params = _get_mark_notification_params(json.loads(request.get_data()))
    note_ids = params.get('note_ids')

    feed = NotificationFeed(user_id, "user")
    unauthorized_notes = list()
    for note_id in note_ids:
        try:
            feed.get_notification(note_id)
        except NotificationNotFoundError:
            unauthorized_notes.append(note_id)

    seen_notes = list(set(note_ids) - set(unauthorized_notes))
    feed.mark_activities(seen_notes, seen=True)

    return (flask.jsonify({'seen_notes': seen_notes,
                           'unauthorized_notes': unauthorized_notes}), 200)


@api_v1.route('/notifications/expire', methods=['POST'])
@cross_origin()
def expire_notifications():
    """
    Notifications can be forced to expire (set their expiration time to now).
    This route (/api/V1/notifications/expire) can only be used by services. There's
    a separate route for admins (see admin_v1.expire_notifications)
    Expects JSON in the body formatted like this:
    {
        "note_ids": [notification ids],
        "external_keys": [keys],
        "source": source_service
    }
    The id keys are both optional, but at least one must be present. Any combination of external
    keys or ids is acceptable, even if they're the same notification.

    This returns the following:
    {
        "expired": {
            "note_ids": [],
            "external_keys": []
        }
        "unauthorized": {
            "note_ids": [],
            "external_keys": []
        }
    }
    This should just return the same lists of values that were input, just shuffled to
    their final status.
    """
    validate_service_token(get_auth_token(request))
    data = parse_expire_notifications_params(json.loads(request.get_data()))
    manager = NotificationManager()
    result = manager.expire_notifications(
        data.get('note_ids', []),
        data.get('external_keys', []),
        source=data.get('source'),
        is_admin=False
    )
    return (flask.jsonify(result), 200)


def _get_mark_notification_params(params):
    if not isinstance(params, dict):
        raise IllegalParameterError('Expected a JSON object as an input.')

    if 'note_ids' not in params:
        raise MissingParameterError("Missing parameter note_ids")

    if not isinstance(params.get('note_ids'), list):
        raise IllegalParameterError('Expected a List object as note_ids.')

    return params
